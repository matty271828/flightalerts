package google

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/google/uuid"
	sheets "google.golang.org/api/sheets/v4"
)

type SheetsService struct {
	Service *sheets.Service
}

func NewSheetsService(client *http.Client) (*SheetsService, error) {
	service, err := sheets.New(client)
	if err != nil {
		return nil, err
	}

	log.Println("Successfully initialised sheets service")
	return &SheetsService{Service: service}, nil
}

const (
	allFlights   = "all_flights"
	readMessages = "read_messages"
	cutoff       = "cutoff"
)

// FlightData is a custom type used to serve flight information
// to google sheets.
type FlightData struct {
	ID          string
	Date        string
	Type        string
	Stops       string
	Airline     string
	Origin      string
	Destination string
	Duration    string
	URL         string
	Price       string
	Discount    string
}

// validateFlightData is used to validate that all fields in a struct of
// FlightData have been populated. The exception is discounts, which is optional.
// ID is also not included since this will be generated by us.
func (f *FlightData) validateFlightData() bool {
	switch {
	case f.Date == "":
		return false
	case f.Type == "":
		return false
	case f.Type == "":
		return false
	case f.Airline == "":
		return false
	case f.Origin == "":
		return false
	case f.Destination == "":
		return false
	case f.Duration == "":
		return false
	case f.URL == "":
		return false
	case f.Price == "":
		return false
	}
	return true
}

// prepareDataForSheets is used to transform the custom type FlightData
// into a format expected by google sheets.
func prepareFlightDataForSheet(data []FlightData) [][]interface{} {
	var result [][]interface{}
	for _, fd := range data {
		result = append(result, []interface{}{
			uuid.New().String(), fd.Date, fd.Type, fd.Stops, fd.Airline, fd.Origin, fd.Destination, fd.Duration, fd.URL, fd.Price, fd.Discount,
		})
	}
	return result
}

// AppendFlightData is used to add row(s) of FlightData to the
// flight_data sheet in Google Sheets.
func (s *SheetsService) AppendFlightData(data []FlightData) error {
	spreadsheetId := os.Getenv("SPREADSHEET_ID")
	if spreadsheetId == "" {
		return fmt.Errorf("SPREADSHEET_ID is not set")
	}
	rangeToWrite := allFlights + "!A1" // Starting range, append will handle the rest

	// Prepare the data for appending
	values := prepareFlightDataForSheet(data)
	vr := &sheets.ValueRange{Values: values}

	_, err := s.Service.Spreadsheets.Values.Append(spreadsheetId, rangeToWrite, vr).ValueInputOption("RAW").InsertDataOption("INSERT_ROWS").Context(context.Background()).Do()
	if err != nil {
		return err
	}
	log.Println("Flight Data appended to sheet")
	return nil
}

// MessageMetaData is a custom type used to serve metadata
// on already read emails to Google Sheets. This metadata is then
// used to ensure FlightData is not duplicated when parsing emails.
type MessageMetaData struct {
	ID           string
	InternalDate string
}

// prepareMessageMetaDataForSheet is used to transform a single ID
// into a format expected by Google Sheets.
func prepareMessageMetaDataForSheet(metaData *MessageMetaData) [][]interface{} {
	return [][]interface{}{
		{metaData.ID, metaData.InternalDate},
	}
}

// MarkMessageAsRead is used to add a message id and date of the message
// to a sheet tracking previously read messages.
func (s *SheetsService) MarkMessageAsRead(id string, internalDate string) error {
	spreadsheetId := os.Getenv("SPREADSHEET_ID")
	if spreadsheetId == "" {
		return fmt.Errorf("SPREADSHEET_ID is not set")
	}

	rangeToWrite := readMessages + "!A1" // Starting range, append will handle the rest

	metaData := MessageMetaData{ID: id, InternalDate: internalDate}
	values := prepareMessageMetaDataForSheet(&metaData)
	vr := &sheets.ValueRange{Values: values}

	_, err := s.Service.Spreadsheets.Values.Append(spreadsheetId, rangeToWrite, vr).ValueInputOption("RAW").InsertDataOption("INSERT_ROWS").Context(context.Background()).Do()
	if err != nil {
		return err
	}
	log.Println("Message successfully marked as read")
	return nil
}

// MarkMessageAsCutoff is used to save the metadata of the cutoff message.
// The cutoff message is the first read message of the previous run, so for subsequent
// runs we do not need to keep reading once we reach it.
func (s *SheetsService) MarkMessageAsCutoff(id string, internalDate string) error {
	spreadsheetId := os.Getenv("SPREADSHEET_ID")
	if spreadsheetId == "" {
		return fmt.Errorf("SPREADSHEET_ID is not set")
	}

	rangeToWrite := cutoff + "!A2"

	metaData := MessageMetaData{ID: id, InternalDate: internalDate}
	values := prepareMessageMetaDataForSheet(&metaData)
	vr := &sheets.ValueRange{Values: values}

	_, err := s.Service.Spreadsheets.Values.Update(spreadsheetId, rangeToWrite, vr).ValueInputOption("RAW").Context(context.Background()).Do()
	if err != nil {
		return err
	}
	log.Println("Message successfully marked as cutoff")
	return nil
}

// GetCutoffMessageMetadata is used to find the last previously read message in order
// to act as a cutoff for reading emails.
// GetCutoffMessageMetadata retrieves the metadata of the cutoff message, which
// is always stored in the second row. The cutoff message is used as a marking
// point to stop reading previously read emails.
func (s *SheetsService) GetCutoffMessageMetadata() (*MessageMetaData, error) {
	spreadsheetId := os.Getenv("SPREADSHEET_ID")
	if spreadsheetId == "" {
		return nil, fmt.Errorf("SPREADSHEET_ID is not set")
	}

	rangeToRead := fmt.Sprintf("%s!A2:B2", cutoff) // Targeting the second row

	resp, err := s.Service.Spreadsheets.Values.Get(spreadsheetId, rangeToRead).MajorDimension("ROWS").Do()
	if err != nil {
		return nil, fmt.Errorf("unable to retrieve data from sheet: %v", err)
	}

	// No error since this indicates that the second row might be empty
	if len(resp.Values) == 0 || len(resp.Values[0]) < 1 {
		// If the second row is empty or incomplete, return nil
		return nil, nil
	}

	latestRow := resp.Values[0]
	messageMetaData := &MessageMetaData{
		ID:           fmt.Sprintf("%v", latestRow[0]),
		InternalDate: fmt.Sprintf("%v", latestRow[1]),
	}

	return messageMetaData, nil
}
